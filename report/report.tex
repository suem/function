\documentclass[11pt,a4paper,titlepage]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{algpseudocode} 
\usepackage{algorithm}
\usepackage{amsmath,amssymb,graphicx,listings,stmaryrd}
\usepackage{tcolorbox}
\usepackage{subcaption}

\algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}
\algnewcommand\True{\textbf{true}\space}
\algnewcommand\False{\textbf{false}\space}

\newtheorem{definition}{Definition}[section]
 
\usepackage[linkcolor=black,colorlinks=true,citecolor=black,filecolor=black]{hyperref}

\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{arrows, automata}

\newcommand\eqdef{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}

\setlength{\parindent}{0pt}

\title{Proving Temporal Properties by Abstract Interpretation}
\date{September 6, 2017}
\author{Samuel Marco Ueltschi}


\begin{document}

\maketitle

\tableofcontents
\clearpage

\section{Introduction}
 
Motivation etc.

This section introduces the necessary background for understanding the main concepts described in this thesis.
Note that we assume that the reader already has a basic understanding of abstract interpretation. An detailed introduction into 
the theory of abstract interpretation can be found in [TODO].


\section{State Transition Systems}

To be able to analyse the behaviour of a program, it is necessary 
to express said behavior through a mathematical model. 
We model the operational semantics of programs using transition systems. 
This is based on the definitions presented in~\cite{UrbanM-VMCAI15}.

\begin{definition}{Transition System}
    A transition system is a tuple $\langle \Sigma, \tau \rangle$ where $\Sigma$ 
    is the set of all states in the system and $\tau \in \Sigma \times \Sigma$ 
    is the so called transition relations that defines how one can transition from one state to the other.
\end{definition}

Transition systems allow us to model the semantics of a program 
independently of the programming language in which it was written. 
By expressing the possible transition between states in terms of a relation, 
it is also possible to capture nondeterminism. Figure~\ref{fig:basic_transition_system} 
shows a simple transition system represented as directed graphs. States are represented as nodes
and state transitions as directed edges.
\\

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick]
    \tikzset{every state/.style={minimum size=0pt}}

    \node[state] (A)                    {$a$};
    \node[state] (B) [below left of=A] {$b$};
    \node[state] (C) [below right of=A]  {$c$};
    \node[state] (D) [below of=C] {$d$};

    \path (A) edge              node {} (B);
    \path (A) edge              node {} (C);
    \path (C) edge              node {} (D);
\end{tikzpicture}
\caption{A basic state transition system} 
\label{fig:basic_transition_system}
\end{figure}


We introduce the following auxiliary functions over states of a transition systems which will become 
useful in section (TODO ref XY) where we defined the semantics of CTL operators in terms of transition systems.

\begin{definition}\label{def:pre}
    Given a transition system $\langle \Sigma, \tau \rangle$. $\text{pre} \colon \mathcal{P}(\Sigma) \to \mathcal{P}(\Sigma)$
    maps a set of states $X \in \mathcal{P}(\Sigma)$ to the set of their predecessors with respect to the program transition
    relation $\tau$:
\begin{equation}
    \text{pre}(X) \eqdef \{s \in \Sigma \ | \ \exists s' \in X \colon \langle s, s' \rangle \in \tau \}  
\end{equation}
\end{definition}


\begin{definition}\label{def:tilde_pre}
    Given a transition system $\langle \Sigma, \tau \rangle$. $\widetilde{\text{pre}} \colon \mathcal{P}(\Sigma) \to \mathcal{P}(\Sigma)$
    maps a set of states $X \in \mathcal{P}(\Sigma)$ to the set of their predecessors with respect to the program transition
    relation $\tau$ with the limitation that only those predecessor states are selected which exclusively transition to states in $X$:
\begin{equation}
    \widetilde{\text{pre}}(X) \eqdef \{s \in \Sigma \ | \ \forall s' \in X \colon \langle s, s' \rangle \in \tau \Rightarrow s' \in X \}  
\end{equation}
\end{definition}

To get an intuition for the difference between $\widetilde{\text{pre}}$ and $\text{pre}$, consider the state transition system 
depicted in figure~\ref{fig:basic_transition_system}. There it holds that $\text{pre}(\{b, d\}) = \{a, c\}$ 
because $a$ is the predecessor of $b$ and $c$ the predecessor of $d$. 
However note that $\widetilde{\text{pre}}(\{b, d\}) = \{c\}$ since only $c$ has 
transitions that exclusively end up in either $b$ or $d$. 
Consequently it holds that $\widetilde{\text{pre}}(\{b, c\}) = \{a\}$ because $a$ transitions exclusively to either $b$ or $c$.


\section{Computation Tree Logic (CTL)}\label{sec:computation_tree_logic}

Computation Tree Logic (CTL) is a logic which allows us to state properties about possible execution traces of state transition systems. 
In the context of this thesis, CTL is used to express temporal properties about the runtime behaviour of programs. 
This section gives a brief introduction into the syntax and semantic of CTL. 
Further information about CTL can be found in~\cite{baier2008principles}.

\subsection{Syntax}
The syntax of a CTL formula is given by the following grammar definition.

\begin{align*}
    \Phi  ::= \ & \\ 
    & a \ | \\
    & \neg \Phi \ | \ \Phi \land \Phi \ | \ \Phi \lor \Phi \ | \\
    & \forall\bigcirc\Phi \ | \ \exists\bigcirc\Phi \ | \\
    & \forall\lozenge\Phi \ | \ \exists\lozenge\Phi \ | \\
    & \forall\square\Phi \ | \ \exists\square\Phi \ | \\
    & \forall(\Phi \ U \ \Phi) | \ \exists(\Phi \ U \ \Phi) 
\end{align*}

The term $a$ is a placeholder for arbitrary atomic propositions.

\subsection{Semantic}

We now define the satisfaction relation $\models$ between states $\sigma \in \Sigma$ and CTL formulae.
The satisfaction relation for atomic propositions depends on the semantics of the underlying 
logic for atomic propositions.

\begin{align*}
    \sigma \models \neg \Phi  &\iff \text{not} \ \sigma \models \Phi \\ 
    \sigma \models \Phi_1 \land \Phi_2   &\iff (\sigma \models \Phi_1) \ \text{and} \ (\sigma \models \Phi_1) \\ 
    \sigma \models \Phi_1 \lor \Phi_2   &\iff (\sigma \models \Phi_1) \ \text{or} \ (\sigma \models \Phi_1) \\ 
    \sigma \models \forall\bigcirc\Phi &\iff \ \forall \pi \in Paths(\sigma) \colon (\pi [1] \models \Phi) \\ 
    \sigma \models \exists\bigcirc\Phi &\iff \ \exists \pi \in Paths(\sigma) \colon (\pi [1] \models \Phi) \\ 
    \sigma \models \forall(\Phi_1 \ U \ \Phi_2) &\iff \ \forall \pi \in Paths(\sigma) \colon 
    (\exists j \geq 0 \colon \pi[j] \models \Phi_2 \land (\forall 0 \leq k < j \colon \pi[k] \models \Phi_1)) \\ 
    \sigma \models \exists(\Phi_1 \ U \ \Phi_2) &\iff \ \exists \pi \in Paths(\sigma) \colon 
    (\exists j \geq 0 \colon \pi[j] \models \Phi_2 \land (\forall 0 \leq k < j \colon \pi[k] \models \Phi_1)) \\ 
    \sigma \models \forall\square\Phi &\iff \ \forall \pi \in Paths(\sigma) \colon (\forall j \geq 0 \colon \pi[j] \models \Phi) \\ 
    \sigma \models \exists\square\Phi &\iff \ \exists \pi \in Paths(\sigma) \colon (\forall j \geq 0 \colon \pi[j] \models \Phi) \\ 
\end{align*}

The states $\sigma \in \Sigma$ are part of a state transition system $\langle \Sigma, \tau \rangle$ and 
$Paths(\sigma_0)$ is the set of all paths $\pi = \sigma_0 \sigma_1 \sigma_2 \dots$ starting from $\sigma_0$ with $\pi[j] = \sigma_j$.
The CTL formulae $\forall\lozenge\Phi$ and $\exists\lozenge\Phi$ are not defined for $\models$ as they are equivalent to 
$\forall(true \ U \ \Phi)$ and $\exists(true \ U \ \Phi)$. Furthermore the following useful equivalence relations 
exists which can be used to relate existential to universal CTL formulae.

\begin{align*}
    \exists\bigcirc\Phi &\equiv \neg \forall\bigcirc(\neg \Phi)\\ 
    \exists\lozenge\Phi &\equiv \neg \forall\square(\neg \Phi) \\
    \exists\square\Phi  &\equiv \neg \forall\lozenge(\neg \Phi) \\
\end{align*}

\subsection{Recurrence and Guarantee Properties}
TODO


\section{Ranking Functions}\label{sec:ranking_functions}

The traditional approach for proving termination is based on inferring \textit{ranking functions}~\cite{Touring49}~\cite{Floyd67}.
A ranking function is a partial function from program states to a well-ordered set (e.g.\ the natural numbers). 
To prove termination, the values of the ranking functions must decrease during program execution. Therefore the value that a \textit{ranking function} assigns to a state is an upper bound on the number of steps until the program terminates.
Cousot and Cousot prove the existence of a \textit{most precise ranking function} then can be derived 
by abstract interpretation \cite{CousotCousot-POPL12}. The theory of abstract interpretation makes it possible to express 
various aspects of the semantics of a program. In that context the \textit{most precise ranking function} for termination is called
the \textit{termination semantics}.

\begin{definition}
    The \textit{termination semantics} is a ranking function 
    $\tau^{t} \in \Sigma \rightarrow \mathbb{N}$.
    A program starting from some state $\sigma \in \Sigma$ terminates if and only if $\sigma \in dom(\tau^{t})$.
\end{definition}

By definition of the \textit{termination semantics}, a program will terminate if its initial state is in the domain of
the ranking function. In other words, if the termination semantics assigns a natural value to the initial state that
is an upper bound on the number of steps until termination.\\


Based on the work of Cousot and Cousot~\cite{CousotCousot-POPL12}. Urban and Miné~\cite{UrbanM-VMCAI15} extended the 
\textit{termination semantics} to the more general notion of guarantee properties. A guarantee property states that
some state satisfying a given property is guaranteed to be reached eventually. Termination is therefore just a 
guarantee property stating that some final state will be reached eventually. As with termination, 
the \textit{guarantee semantics} is a ranking function that assigns each state an upper bound on the number of steps
until a state satisfying the given property is reached.

\begin{definition}
    The \textit{guarantee semantics} is a ranking function 
    $\tau_{[S]}^{g} \in \Sigma \rightarrow \mathbb{N}$
    where $S \subseteq \Sigma$ is a set of states satisfying a desired property.
    A program starting from some state $\sigma \in \Sigma$ will reach a state 
    $s \in S$ if and only if $\sigma \in dom(\tau_{[S]}^{g})$.
\end{definition}

In addition to guarantee properties, Urban and Miné~\cite{UrbanM-VMCAI15} also introduced the \textit{recurrence semantics}.
A recurrence property guarantees that a program starting from some state $\sigma \in \Sigma$ will reach some state satisfying
a given property infinitely often. The value assigned to a state by the \textit{recurrence semantics}
is an upper bound on the number of executions steps until a state satisfying the property is reached the next time. 

\begin{definition}
    The \textit{recurrence semantics} is a ranking function 
    $\tau_{[S]}^{r} \in \Sigma \rightarrow \mathbb{N}$
    where $S \subseteq \Sigma$ is a set of states satisfying a desired property.
    A program starting from some state $\sigma \in \Sigma$ will reach a state 
    $s \in S$ infinitely often if and only if $\sigma \in dom(\tau_{[S]}^{r})$.
\end{definition}

Figure~\ref{fig:ranking_functios_example} shows an example for the semantics discussed in this section.
We illustrate the ranking functions by labeling the states in the transition systems with the corresponding value assigned to them by the ranking functions. 
The first example (a) shows the \textit{termination semantics} for a state transition system that always terminates. Therefore the initial state
has the value $2$ assigned to it stating that this program terminates in at most two steps.\\

The second example (b) shows the \textit{guarantee semantics} for the guarantee property that states that a gray state will be reached eventually.
This holds for example (b) therefore the initial state has the value $2$ assigned to it. The program reaches a gray state in at most two steps.\\

The last example (c) shows the \textit{recurrence semantics} for the recurrence property that states that a gray state will be reached infinitely often.
As one can see from the transition system, this is not true when starting from the initial state. Therefore the \textit{recurrence semantics} is undefined
for the initial state. However the property would hold when starting from state $c$ or $d$. 
Accordingly these two states have the values $1$ and $0$ assigned to them.\\

We refer to~\cite{UrbanPhd} for a detailed discussion of the various semantics presented in this session.

\begin{figure}
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,node distance=1.5cm,thin]
            \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
            \node[state, label=left:{2}] (A) {a};
            \node[state, label=left:{0}] (B) [below left of=A] {b};
            \node[state, label=left:{1}] (C) [below right of=A] {c};
            \node[state, label=left:{0}] (D) [below of=C] {d};
            \path (A) edge              node {} (B);
            \path (A) edge              node {} (C);
            \path (C) edge              node {} (D);
        \end{tikzpicture}
        \caption{$\tau^{t}$}
    \end{subfigure}
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,node distance=1.5cm,thin]
            \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
            \node[state, label=left:{2}] (A) {a};
            \node[state, fill=gray!20, label=left:{0}] (B) [below left of=A] {b};
            \node[state, label=left:{1}] (C) [below right of=A] {c};
            \node[state, fill=gray!20, label=left:{0}] (D) [below of=C] {d};
            \node[state] (E) [below of=B] {e};
            \path (A) edge              node {} (B);
            \path (A) edge              node {} (C);
            \path (C) edge[bend right]             node {} (D);
            \path (D) edge[bend right]              node {} (C);
            \path (B) edge              node {} (E);
        \end{tikzpicture}
        \caption{$\tau_{[\{b, d\}]}^{g}$}
    \end{subfigure}
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,node distance=1.5cm,thin]
            \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
            \node[state] (A) {a};
            \node[state, fill=gray!20] (B) [below left of=A] {b};
            \node[state, label=left:{1}] (C) [below right of=A] {c};
            \node[state, fill=gray!20, label=left:{0}] (D) [below of=C] {d};
            \node[state] (E) [below of=B] {e};
            \path (A) edge              node {} (B);
            \path (A) edge              node {} (C);
            \path (C) edge[bend right]             node {} (D);
            \path (D) edge[bend right]              node {} (C);
            \path (B) edge              node {} (E);
        \end{tikzpicture}
        \caption{$\tau_{[\{b, d\}]}^{r}$}
    \end{subfigure}
    \caption{
        Example \textit{termination\ semantics} (a), 
        \textit{guarantee\ semantics} (b) and
        \textit{recurrence\ semantics} (c)
    } 
    \label{fig:ranking_functios_example}
\end{figure}

\section{Concrete Semantics for CTL}\label{sec:ctl_semantics}
In section XY (TODO ref) we introduced the concept of ranking functions and explained how they express the semantics of 
recurrence and guarantee properties. To be able to analyse CTL properties, we extend the notion of ranking functions to CTL. 
Urban et al.~\cite{UrbanM-VMCAI15} define ranking functions for guarantee and recurrence properties.
The CTL semantics presented here are an extension of this work. We will define the \textit{CTL semantics} inductively 
for each CTL operator such that arbitrary combinations of CTL properties can be analyzed. 

\begin{definition}
    The \textit{CTL semantics} for a given CTL formula $\Phi$ is a ranking function 
    $\tau_{\Phi} \in \Sigma \rightarrow \mathbb{N}$. 
    It encodes the semantics of $\Phi$ for a given state transition 
    system $\langle \Sigma, \tau \rangle$ such that $\sigma \models \Phi \iff \sigma \in dom(\tau_{\Phi})$ holds. 
\end{definition}

The definition of the concerete CTL semantics will be split into path dependent and independent CTL operators. 

\subsection{Path Independent Operators}

We start by defining the \textit{CTL semantics} for atomic propositions and logic operators (see definition~\ref{def:ctl_semantics_basic}). 
These CTL properties are path independent and can be defined independently for each state $\sigma \in \Sigma$.
The definitions follow directly from the satisfiability relation for CTL properties (see section~\ref{sec:computation_tree_logic}). 

\begin{definition}\label{def:ctl_semantics_basic}
    Equations for path independent CTL operators
    \setlength{\jot}{15pt}
    \begin{align}
        \tau_a &\eqdef \lambda \sigma.
        \begin{cases}
            0                   & \text{if} \ \sigma \models a \\
            \text{undefined}    & \text{otherwise}
        \end{cases}\\
        %
        \tau_{\neg \Phi} &\eqdef \lambda \sigma.
        \begin{cases}
            0                   & \text{if} \ \sigma \notin dom(\tau_{\Phi}) \\
            \text{undefined}    & \text{otherwise}
        \end{cases}\label{eq:ctl_not}
        \\
        %
        \tau_{\Phi_1 \land \Phi_2} &\eqdef \lambda \sigma.
        \begin{cases}
            \sup\{\tau_{\Phi_1}(s), \tau_{\Phi_2}(\sigma)\} 
                                &\text{if } \sigma \in dom(\tau_{\Phi_1}) \cap dom(\tau_{\Phi_2}) \\
            \text{undefined}    & \text{otherwise}
        \end{cases}\\
        %
        \tau_{\Phi_1 \lor \Phi_2} &\eqdef \lambda \sigma.
        \begin{cases}
            \sup\{\tau_{\Phi_1}(\sigma), \tau_{\Phi_2}(\sigma)\}         & \text{if} \ \sigma \in dom(\tau_{\Phi_1}) \cap dom(\tau_{\Phi_2}) \\
            \tau_{\Phi_1}(\sigma)                                        & \text{if} \ \sigma \in dom(\tau_{\Phi_1}) \setminus dom(\tau_{\Phi_2}) \\
            \tau_{\Phi_2}(\sigma)                                        & \text{if} \ \sigma \in dom(\tau_{\Phi_2}) \setminus dom(\tau_{\Phi_1}) \\
            \text{undefined}    & \text{otherwise}
        \end{cases}
    \end{align}
\end{definition}

\subsection{Path Dependent Operators}

CTL semantics for path dependent operators `until' and `global' are be defined in terms of fixed-points. 
These fixed-points are defined for the partially ordered set of ranking functions $\langle \Sigma \rightarrow \mathbb{N}, \sqsubseteq \rangle$. 
Ranking functions are related to each other using the \textit{computational order} $\sqsubseteq$. 
This partial order relates ranking functions in terms of expressiveness i.e.\ for how many states can a ranking function prove that the CTL property holds.

\begin{definition}\label{def:computational_order}
    Let $f, g \in \Sigma \rightarrow \mathbb{N}$. 
    The \textit{computational order} $\sqsubseteq$ is defined as follows.
    \begin{align*}
        f \sqsubseteq g \iff \text{dom}(f) \subseteq \text{dom}(g) \land \forall x \text{dom}(f): f(x) \leq g(x) \\
    \end{align*}
\end{definition}

\subsubsection*{Until}

The CTL semantics for universal and existential `until' properties are defined as least fixed-point of the abstract transformers
\[
\phi_{\forall(\Phi_1 U \Phi_2)}, \phi_{\exists(\Phi_1 U \Phi_2)} 
\in (\Sigma \rightarrow \mathbb{N}) \rightarrow (\Sigma \rightarrow \mathbb{N}))
\]

starting from the totally undefined ranking function $\overset{.}{\emptyset}$ (see definition~\ref{def:ctl_semantics_until}).
This definition is an generalization of the \textit{guarantee semantics} presented in~\cite{UrbanM-VMCAI15}. 

\begin{definition}\label{def:ctl_semantics_until}
    CTL semantics for existential and universal until properties
    \setlength{\jot}{15pt}
    \begin{align}
        \tau_{\forall(\Phi_1 U \Phi_2)}  &\eqdef \text{lfp}_{\overset{.}{\emptyset}}^{\sqsubseteq} \ \phi_{\forall(\Phi_1 U \Phi_2)}\\
        \phi_{\forall(\Phi_1 U \Phi_2)}f &\eqdef \lambda \sigma.
        \begin{cases}
            0                                                           
                & \text{if} \ \sigma \in dom(\tau_{\Phi_2}) \\
            \sup\{ f(\sigma') + 1 \ | \ \langle \sigma,\sigma' \rangle \in \tau \}    
                & \text{if} \ \sigma \notin dom(\tau_{\Phi_2}) \ \land \\ 
                & \sigma \in dom(\tau_{\Phi_1}) \ \land \\ 
                & \sigma \in \widetilde{pre}(dom(f)) \\
            \text{undefined}                                            
                & \text{otherwise}
        \end{cases}\\
        \tau_{\exists(\Phi_1 U \Phi_2)}  &\eqdef \text{lfp}_{\overset{.}{\emptyset}}^{\sqsubseteq} \ \phi_{\exists(\Phi_1 U \Phi_2)}\\
        \phi_{\exists(\Phi_1 U \Phi_2)}f &\eqdef \lambda \sigma.
        \begin{cases}
            0                                                           
                & \text{if} \ \sigma \in dom(\tau_{\Phi_2}) \\
            \sup\{ f(\sigma') + 1 \ | \ \langle \sigma,\sigma' \rangle \in \tau \}    
                & \text{if} \ \sigma \notin dom(\tau_{\Phi_2}) \ \land \\ 
                & \sigma \in dom(\tau_{\Phi_1}) \ \land \\ 
                & \sigma \in pre(dom(f)) \\
            \text{undefined}                                            
                & \text{otherwise}
        \end{cases}
    \end{align}
\end{definition}


Recall that for the CTL property $\forall(\Phi_1 U \Phi_2)$ to hold for some state $\sigma \in \Sigma$, 
all paths starting from said state must be a chain of states satisfying $\Phi_1$ ending in a state satisfying $\Phi_2$.
The fixed-point iteration starts by assigning the value $0$ to all states that satisfy $\Phi_2$. 
In subsequent iterations we consider all states that satisfy $\Phi_1$, and from which one can only transition to states that already satisfy  
$\forall(\Phi_1 U \Phi_2)$. These states are then assigned the largest ranking value of all reachable states plus one. 
By performing iterations this way, we backtrack paths in the state transition systems that end in a state satisfying $\Phi_2$ and which are preceded by an 
unbroken chain of states satisfying $\Phi_1$. Every state on such a path is guaranteed to satisfy the CTL `until' property. 
Furthermore, by starting from $0$ at states that satisfy $\Phi_2$ and increasing while backtracking, 
we are constructing a ranking function in such a way that the value assigned to each state is an 
upper bound on the number of steps until a state is reached that satisfies $\Phi_2$.\\

The $\widetilde{pre}$ relation guarantees that during the backtracking, only those states are considered which 
exclusively transition to states satisfying $\forall(\Phi_1 U \Phi_2)$. 
This condition can be relaxed for existential `until' properties by using the $pre$ relation instead. 
That way, states that have at least one reachable state satisfying $\exists(\Phi_1 U \Phi_2)$ are also considered 
during the backtracking (see definitions~\ref{def:pre} and~\ref{def:tilde_pre}).\\

Figures~\ref{fig:ctl_semantics_universal_until} and~\ref{fig:ctl_semantics_existential_until} give an example on how the
iterative computation for `until' works for universal and existential properties. 
Note how figure~\ref{fig:ctl_semantics_existential_until} has one additional iteration because of the existential quantifier. 
The initial state is added to ranking function in the last iteration because there exists one edge that leads to a state satisfying the property.  
For the universal property, the iteration stops after three iterations because not all successor states
of the initial state satisfy the property.


\begin{figure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
                \node[state, fill=gray] (A) {};
                \node[state] (B) [below left of=A] {};
                \node[state, fill=gray] (C) [below right of=A] {};
                \node[state, fill=black] (D) [below left of=C] {};
                \node[state, fill=gray] (E) [below right of=C] {};
                \node[state, fill=black] (F) [below of=E] {};
                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge              node {} (D);
                \path (C) edge              node {} (E);
                \path (E) edge              node {} (F);
            \end{tikzpicture}
        }
        \caption{Iteration 0}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}

                \node[state, fill=gray] (A) {};
                \node[state] (B) [below left of=A] {};
                \node[state, fill=gray] (C) [below right of=A] {};
                \node[state, fill=black, label=left:{0}] (D) [below left of=C] {};
                \node[state, fill=gray] (E) [below right of=C] {};
                \node[state, fill=black, label=left:{0}] (F) [below of=E] {};

                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge              node {} (D);
                \path (C) edge              node {} (E);
                \path (E) edge              node {} (F);
            \end{tikzpicture}
        }
        \caption{Iteration 1}
    \end{subfigure}
    \par\bigskip
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}

                \node[state, fill=gray] (A) {};
                \node[state] (B) [below left of=A] {};
                \node[state, fill=gray] (C) [below right of=A] {};
                \node[state, fill=black, label=left:{0}] (D) [below left of=C] {};
                \node[state, fill=gray, label=right:{1}] (E) [below right of=C] {};
                \node[state, fill=black, label=left:{0}] (F) [below of=E] {};

                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge              node {} (D);
                \path (C) edge              node {} (E);
                \path (E) edge              node {} (F);
            \end{tikzpicture}
        }
        \caption{Iteration 2}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,thin]

                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}

                \node[state, fill=gray] (A) {};
                \node[state] (B) [below left of=A] {};
                \node[state, fill=gray, label=right:{2}] (C) [below right of=A] {};
                \node[state, fill=black, label=left:{0}] (D) [below left of=C] {};
                \node[state, fill=gray, label=right:{1}] (E) [below right of=C] {};
                \node[state, fill=black, label=left:{0}] (F) [below of=E] {};

                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge              node {} (D);
                \path (C) edge              node {} (E);
                \path (E) edge              node {} (F);
            \end{tikzpicture}
        }
        \caption{Iteration 3}
    \end{subfigure}
    \caption{Iterative computation of $\tau_{\forall(gray \ U \ black)}$.} 
    \label{fig:ctl_semantics_universal_until}
\end{figure}




\begin{figure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
                \node[state, fill=gray] (A) {};
                \node[state] (B) [below left of=A] {};
                \node[state, fill=gray] (C) [below right of=A] {};
                \node[state, fill=black] (D) [below left of=C] {};
                \node[state, fill=gray] (E) [below right of=C] {};
                \node[state, fill=black] (F) [below of=E] {};
                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge              node {} (D);
                \path (C) edge              node {} (E);
                \path (E) edge              node {} (F);
            \end{tikzpicture}
        }
        \caption{Iteration 0}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}

                \node[state, fill=gray] (A) {};
                \node[state] (B) [below left of=A] {};
                \node[state, fill=gray] (C) [below right of=A] {};
                \node[state, fill=black, label=left:{0}] (D) [below left of=C] {};
                \node[state, fill=gray] (E) [below right of=C] {};
                \node[state, fill=black, label=left:{0}] (F) [below of=E] {};

                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge              node {} (D);
                \path (C) edge              node {} (E);
                \path (E) edge              node {} (F);
            \end{tikzpicture}
        }
        \caption{Iteration 1}
    \end{subfigure}
    \par\bigskip
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}

                \node[state, fill=gray] (A) {};
                \node[state] (B) [below left of=A] {};
                \node[state, fill=gray] (C) [below right of=A] {};
                \node[state, fill=black, label=left:{0}] (D) [below left of=C] {};
                \node[state, fill=gray, label=right:{1}] (E) [below right of=C] {};
                \node[state, fill=black, label=left:{0}] (F) [below of=E] {};

                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge              node {} (D);
                \path (C) edge              node {} (E);
                \path (E) edge              node {} (F);
            \end{tikzpicture}
        }
        \caption{Iteration 2}
    \end{subfigure}
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,thin]

                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}

                \node[state, fill=gray] (A) {};
                \node[state] (B) [below left of=A] {};
                \node[state, fill=gray, label=right:{2}] (C) [below right of=A] {};
                \node[state, fill=black, label=left:{0}] (D) [below left of=C] {};
                \node[state, fill=gray, label=right:{1}] (E) [below right of=C] {};
                \node[state, fill=black, label=left:{0}] (F) [below of=E] {};

                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge              node {} (D);
                \path (C) edge              node {} (E);
                \path (E) edge              node {} (F);
            \end{tikzpicture}
        }
        \caption{Iteration 3}
    \end{subfigure}
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,thin]

                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}

                \node[state, fill=gray, label=right:{3}] (A) {};
                \node[state] (B) [below left of=A] {};
                \node[state, fill=gray, label=right:{2}] (C) [below right of=A] {};
                \node[state, fill=black, label=left:{0}] (D) [below left of=C] {};
                \node[state, fill=gray, label=right:{1}] (E) [below right of=C] {};
                \node[state, fill=black, label=left:{0}] (F) [below of=E] {};

                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge              node {} (D);
                \path (C) edge              node {} (E);
                \path (E) edge              node {} (F);
            \end{tikzpicture}
        }
        \caption{Iteration 4}
    \end{subfigure}
    \caption{Iterative computation of $\tau_{\exists(gray \ U \ black)}$.} 
    \label{fig:ctl_semantics_existential_until}
\end{figure}


\subsubsection*{Global}

The CTL semantics for universal and existential `global' properties are defined as greates fixed-point of the abstract transformers
\[
\phi_{\forall(\Phi_1 U \Phi_2)}, \phi_{\exists(\Phi_1 U \Phi_2)} 
\in (\Sigma \rightarrow \mathbb{N}) \rightarrow (\Sigma \rightarrow \mathbb{N}))
\]
starting from the CTL semantics $\tau_\Phi$ of the inner CTL property (see definition~\ref{def:ctl_semantics_global}).
This definition is based on the \textit{recurrence semantics} presented in~\cite{UrbanM-VMCAI15}.

\begin{definition}\label{def:ctl_semantics_global}
    Equations for CTL global operator
    \setlength{\jot}{15pt}
    \begin{align}
        \tau_{\forall\square\Phi} &\eqdef \text{gfp}_{\tau_\Phi}^{\sqsubseteq} \  \phi_{\forall\square\Phi}\\
        \phi_{\forall\square\Phi}f &\eqdef \lambda \sigma.
        \begin{cases}
            f(x)                            & \text{if} \ \sigma \in \widetilde{pre}(dom(f)) \\
            \text{undefined}                & \text{otherwise}
        \end{cases}\\
        \tau_{\exists\square\Phi} &\eqdef \text{gfp}_{\tau_\Phi}^{\sqsubseteq} \  \phi_{\exists\square\Phi}\\
        \phi_{\exists\square\Phi}f &\eqdef \lambda \sigma.
        \begin{cases}
            f(x)                            & \text{if} \ \sigma \in pre(dom(f)) \\
            \text{undefined}                & \text{otherwise}
        \end{cases}
    \end{align}
\end{definition}


The CTL `global' operator states that some property must hold globally i.e. indefinitely for 
\textit{all} paths starting from some state in the case of the universal
quantifier ($\forall\square\Phi$) or \textit{some} path in case of the existential quantifier ($\exists\square\Phi$). 
As with the `until' operator, we distinguish between universal and existential properties by using either $\widetilde{pre}$ or $pre$. 
The fixed-point iteration starts with the ranking function $\tau_\Phi$ of the inner property.
In each iteration, every state that is still part of the domain of the ranking function is inspected. 
The inspected state is kept in the domain of the ranking function if \textit{all} its successor states 
(or \textit{some} for the existential case) are also part of the domain of the ranking function, otherwise it is removed.
That way, only those states are kept in the ranking function which are part of an infinite path consisting exclusively of states satisfying $\Phi$.\\

Figures~\ref{fig:ctl_semantics_universal_global} and~\ref{fig:ctl_semantics_existential_global} give an example iteration for 
$\tau_{\exists\square\Phi}$ and $\tau_{\forall\square\Phi}$. Both iterations start with some initial ranking function $\tau_\Phi$.
In the first iteration state `b' is removed because it has no outgoing edges. For the existential case, the iteration stops here because
all remaining states `a', `c' and `'d' have at least one edge to a node thats part of the ranking function. In the universal case we get an additional
iteration that removes state `a' because not all of its successor nodes (namely `b') are part of the ranking function. 

Note that the way $\tau_{\forall\square\Phi}$ and $\tau_{\exists\square\Phi}$ are defined, 
it is not possible to use the `global' operator on finite paths. Only infinite paths are considered to hold globally. 


\begin{figure}

    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',node distance=1.5cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
                \node[state, label=left:{2}] (A) {a};
                \node[state, label=left:{0}] (B) [below left of=A] {b};
                \node[state, label=right:{1}] (C) [below right of=A] {c};
                \node[state, label=right:{0}] (E) [below of=C] {d};
                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge[bend right]              node {} (E);
                \path (E) edge[bend right]              node {} (C);
            \end{tikzpicture}
        }
        \caption{Iteration 0}
    \end{subfigure}
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',node distance=1.5cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
                \node[state, label=left:{2}] (A) {a};
                \node[state, label=left:{}] (B) [below left of=A] {a};
                \node[state, label=right:{1}] (C) [below right of=A] {b};
                \node[state, label=right:{0}] (E) [below of=C] {c};
                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge[bend right]              node {} (E);
                \path (E) edge[bend right]              node {} (C);
            \end{tikzpicture}
        }
        \caption{Iteration 1}
    \end{subfigure}
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',node distance=1.5cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
                \node[state, label=left:{}] (A) {a};
                \node[state, label=left:{}] (B) [below left of=A] {b};
                \node[state, label=right:{1}] (C) [below right of=A] {c};
                \node[state, label=right:{0}] (E) [below of=C] {d};
                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge[bend right]              node {} (E);
                \path (E) edge[bend right]              node {} (C);
            \end{tikzpicture}
        }
        \caption{Iteration 2}
    \end{subfigure}
    \caption{Iterative computation of $\tau_{\forall\square\Phi}$.} 
    \label{fig:ctl_semantics_universal_global}
\end{figure}

\begin{figure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',node distance=1.5cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
                \node[state, label=left:{2}] (A) {a};
                \node[state, label=left:{0}] (B) [below left of=A] {b};
                \node[state, label=right:{1}] (C) [below right of=A] {c};
                \node[state, label=right:{0}] (E) [below of=C] {d};
                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge[bend right]              node {} (E);
                \path (E) edge[bend right]              node {} (C);
            \end{tikzpicture}
        }
        \caption{Iteration 0}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \resizebox{100pt}{!}{
            \begin{tikzpicture}[->,>=stealth',node distance=1.5cm,thin]
                \tikzset{every state/.style={minimum size=0pt, scale=0.8}}
                \node[state, label=left:{2}] (A) {a};
                \node[state, label=left:{}] (B) [below left of=A] {a};
                \node[state, label=right:{1}] (C) [below right of=A] {b};
                \node[state, label=right:{0}] (E) [below of=C] {c};
                \path (A) edge              node {} (B);
                \path (A) edge              node {} (C);
                \path (C) edge[bend right]              node {} (E);
                \path (E) edge[bend right]              node {} (C);
            \end{tikzpicture}
        }
        \caption{Iteration 1}
    \end{subfigure}
    \caption{Iterative computation of $\tau_{\exists\square\Phi}$.} 
    \label{fig:ctl_semantics_existential_global}
\end{figure}


\subsubsection*{Next}

Definition~\ref{def:ctl_semantics_next} defines the CTL `next' operator. The `next' operator is path dependent but it 
is not defined in terms of fixed-point iterations. A state satisfies $\forall\bigcirc\Phi$ if all its successors satisfy the property,
correspondingly $\exists\bigcirc\Phi$ is satisfied if at least one successor satisfies the property. 
This corresonds to the definition of the $\widetilde{pre}$ and $pre$ relations. Zero is assigned to each state
that satisfies the property. 

\begin{definition}\label{def:ctl_semantics_next}
    Equations for CTL next operator
    \setlength{\jot}{15pt}
    \begin{align}
        \tau_{\forall\bigcirc\Phi} &\eqdef \lambda \sigma.
        \begin{cases}
            0                   & \text{if} \ \sigma \in \widetilde{pre}(dom(\tau_\Phi)) \\
            \text{undefined}    & \text{otherwise}
        \end{cases}\\
        \tau_{\exists\bigcirc\Phi} &\eqdef \lambda \sigma.
        \begin{cases}
            0                   & \text{if} \ \sigma \in pre(dom(\tau_\Phi)) \\
            \text{undefined}    & \text{otherwise}
        \end{cases}
    \end{align}
\end{definition}


\section{Imperative Language}\label{sec:imperative_language}

In this section we briefly introduce a minimal imperative programming language. 
It will be used in section~\ref{sec:abstract_ctl_semantics} to define the abstract CTL semantics.
The language has no procedures, pointers or recursion. It is non-deterministic.
Variables are integer valued ($\mathbb{Z}$) and statically allocated. 


First we define the syntax for arithmetic and boolean expressions. 
The syntax definitions are based on chapter 3 of~\cite{UrbanPhd}.

\begin{definition}\label{def:arith_bool_syntax}
    Syntax for arithmetic and boolean expressions. 
    Arithmetic expressions are defined over a set of variables $\mathcal{X}$.
    \begin{align*}
        \setlength{\jot}{15pt}
        aexp \ ::= \ & \ \ X && X \in \mathcal{X} \\
        &| \  [i_1, i_2] && i_1 \in \mathbb{Z} \cup \{ -\infty \},\ i_1 \in \mathbb{Z} \cup \{\infty \},\ i_1 \leq i_2  \\
        &| \  - aexp \\
        &| \  aexp \diamond aexp && \diamond \in \{ +, -, *, / \}\\
        \\
        bexp \ ::= \ & \ \ ?  && \text{non-deterministic choice} \\
        &| \  \neg bexp \\
        &| \  bexp \land bexp \\
        &| \  bexp \lor bexp \\
        &| \  aexp \diamond aexp && \diamond \in \{<, \leq, >, \geq \}\\
    \end{align*}
\end{definition}

The semantics for expressions are defined as expected. 
Please refer to~\cite{UrbanPhd} for a formal definition. 
Note that the symbol `?' stands for non-deterministic choice.\\

Programs are represented as control-flow-graphs (CFG) (see definition~\ref{def:control_flow_graph}). 
A control-flow-graph $(V, E) \in cfg$ consists of a set of nodes $V$ and edges $E$.
Every control point of a program is assigned a label $l \in \mathcal{L}$. 
The nodes in the control-flow-graph correspond to those labels. 
An edge $(u, s, v) \in edge$ states that one can transition from node
$u$ to $v$ by executing statement $s$. 
The \texttt{skip} statements 
transitions from one node to another without doing anything, the boolean expression $bexp$ limits the set of states
that are allowed to transition to the next node and the assignment $X := aexp$ assigns the value of the arithmetic expression $aexp$
to the variable $X$. A program $(\text{cfg}, l_{entry}, l_{exit}) \in prog$ consists of a control-flow-graph and two special 
nodes that defined the entry and exit point of the program.

\begin{definition}\label{def:control_flow_graph}
    Program representation as control-flow-graph. 
    Let $\mathcal{L}$ be the set of program labels.
    \begin{align*}
        \setlength{\jot}{15pt}
        stmt \ ::= \ & \ \ \mathtt{skip} \\
        &| \ bexp \\
        &| \ X := aexp  && X \in \mathcal{X} \\
        \\
        edge \ \eqdef & \ \ \mathcal{L} \times stmt \times \mathcal{L}\\
        cfg \ \eqdef & \ \ \mathcal{P}(\mathcal{L}) \times \mathcal{P}(edge)\\
        prog \ \eqdef & \ \ cfg \times \mathcal{L} \times \mathcal{L}
    \end{align*}
\end{definition}

We introduce the following auxiliary functions on nodes of a control-flow-graph $(V, E) \in cfg$ 
to refere to the incoming and outgoing edges of a node $l \in V$.

\begin{definition}\label{def:cfg_in}
    Given a control-flow-graph $(V, E) \in cfg$ 
    \begin{align*}
        in(l) &\eqdef \{(u, s, v) \in E \ | \ v = l \}\\
        out(l) &\eqdef \{(u, s, v) \in E \ | \ u = l \}\\
    \end{align*}
\end{definition}


\section{Decision Tree Abstract Domain}\label{sec:decision_tree_abstract_domain}

This section briefly recaps the decision tree abstract domain. 
Decision trees encode piecewise-defined ranking functions which are used as an abstraction 
the of general ranking functions (see section~\ref{sec:ranking_functions}). 
First we give a description of the decision tree abstrac domain. 
Then we introduce ordering relations between the elements of the domain and relevant operations on the elements of the domain. 
An in-depth description of the topics covered in this section can be found in~\cite{UrbanPhd}.\\

\subsection{Domain}

The elements of abstract domain are binary decision trees. The nodes of the trees are linear constrains and the leafs are linear functions.
Decision trees partition a state space, given by a set of variables $\mathcal{X}$, into linear partitions. 
Each partition is defined through the conjunction of linear constraints on the path from root to leaf in the decision tree.
The linear function at the leaf determines the value of the ranking function for the corresponding partition of the state space.\\

\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=1.5cm]
        \tikzset{
            inner_node/.style={draw, shape = rectangle, thick},
            leaf/.style={draw, shape = rectangle, rounded corners, thick}
        }
        \node[inner_node] (A) {$x \leq 0$};
        \node[inner_node] (B) [below left of= A] {$y \leq 0$};
        \node[leaf] (C) [below right of= A] {$\lambda x.\ 2x$};
        \node[leaf] (D) [below left of= B] {$\lambda x \ y. \ x + y$};
        \node[leaf] (E) [below right of= B] {$\bot$};
        \path (A) edge              node {} (B);
        \path (A) edge [dashed]              node {} (C);
        \path (B) edge               node {} (D);
        \path (B) edge [dashed]              node {} (E);
    \end{tikzpicture}
    \caption{Example for decision tree}
    \label{fig:decision_tree_example}
\end{figure}

Figure~\ref{fig:decision_tree_example} gives an example for such a decision tree. 
It consists of two nodes with linear constraints $x \leq 0$ and $y \leq 0$. The left most leaf is the function $\lambda x \ y. \ x + y$. 
It is defined for all states satisfying $x \leq 0 \land y \leq 0$ according to the constraints from root to leaf. 
The right most leaf is the function $\lambda x.\ 2x$, it is defined for all states satisfying $\neg (x \leq 0)$ 
(following the right child of a node negates the linear constraint). The leaf in the middle is a bottom node, 
signifying that the function for the corresponding partition is undefined. Combining all constraints and functions of
the decision tree in figure~\ref{fig:decision_tree_example} yields the following partial function:

\[
    f(x, y) = \begin{cases}
            x+y                   & \text{if} \ x \leq 0 \land y \leq 0 \\
            2x                   & \text{if} \ x > 0 \\
            \text{undefined}    & \text{otherwise}
        \end{cases}
\]

Now we formalize the domain using mathematical notations.

\subsubsection*{Constraints}

The constrains at the inner nodes of the decision tree are elements of the 
\textit{linear constraints auxiliary abstract domain} $\mathcal{C}$.  

\[
    \mathcal{C} \eqdef 
    \left
        \{ 
        c_1 X_1 + \dots + c_n X_n + c_{n+1} \geq 0 \
        \middle\vert 
        \begin{array}{l}
            \mathcal{X} = \{X_1, \dots, X_n\}\\
            c_1, \dots, c_n, c_{n+1} \in \mathbb{Z} \\
            gcd(|c_1|, \dots, |c_n|, |c_{n+1}|) = 1
        \end{array}
    \right
    \}
\]

Elements of $\mathcal{C}$ can be instances of the \textit{interval abstract domain}, 
the \textit{octagon abstract domain} or the \textit{polyhedra abstract domain} (TODO cite).\\


\subsubsection*{Functions}

Leafs of the decision trees are elements of the \textit{functions auxiliary abstract domain} $\mathcal{F}$.
Elements of $\mathcal{F}$ are either natural valued functions or one of the two special elements $\top_{\mathcal{F}}$ or $\bot_{\mathcal{F}}$.
The element $\bot_{\mathcal{F}}$ indicates that the value of the ranking functions is undefined for the given partition. 
The element $\top_{\mathcal{F}}$ indicates that the value of the ranking functions is unknown for the given partition.
\[
    \mathcal{F} \eqdef \{ \mathbb{Z}^{|\mathcal{X}|} \rightarrow \mathbb{N} \} \cup \{ \top_{\mathcal{F}}, \ \bot_{\mathcal{F}} \}
\]
Functions that return a constant value $n \in \mathbb{N}$ are written by just stating the constant value e.g. $0 \in \mathcal{F}$ 
denotes the constant function that returns $0$ for every state.\\

In the following sections we will distinguish between so called \textit{defined} and \textit{undefined} leafs. 
A leaf $f \in \mathcal{F}$ is called \textit{defined} if $f$ is neither $\top_{\mathcal{F}}$ nor $\bot_{\mathcal{F}}$  and \textit{undefined} otherwise.
Defined leafs assign an actual value to its partition, therefore the ranking function that the decision tree represents is defined for that partition.


\subsubsection*{Decision Trees}

We now define the decision tree abstract domain $\mathcal{T}$.
An element $t \in \mathcal{T}$ is either a \textit{leaf node} $LEAF \colon f$ consisting of a function $f \in \mathcal{F}$ (denoted $t.f$),
or a \textit{decision node} $NODE\{c\}: l; r$ consists of a linear constraint $c \in \mathcal{C}$ (denoted $t.c$) 
and a left and a right sub tree $l, r \in \mathcal{T}$ 
(denoted $t.l$ and $t.r$).
\[
    \mathcal{T} \eqdef \{LEAF \colon f \ | \ f \in \mathcal{F}\} \cup \{NODE\{c\}: l; r \ | \ c \in \mathcal{C}, l, r \in \mathcal{T} \} 
\]

For algorithmic purposes we also define $\mathcal{T}_{\mathtt{NIL}}$. 
This adds an additional leaf element \texttt{NIL} to $\mathcal{T}$ to represent the absence of information about a partition.
\texttt{NIL} leafs usually appear if some partitons in a decision tree can be excluded because they are infeasible w.r.t the program execution.
\[
    \mathcal{T}_{\mathtt{NIL}} \eqdef \{\mathtt{NIL}\} \ \cup \ \{LEAF \colon f \ | 
    \ f \in \mathcal{F}\} \ \cup \ \{NODE\{c\}: l; r \ | \ c \in \mathcal{C}, l, r \in \mathcal{T}_{\mathtt{NIL}}  \} 
\]


\subsubsection*{Orders \& Abstractions}

Decision trees will be used as an abstraction of ranking functions. It is important to be able to reason about the soundness of this abstraction.
For that purpose we will now introduce a number of partial orders which are then used to express soundness.

For the elements of $\mathcal{F}$ we defined the \textit{computational order} $\sqsubseteq_{\mathcal{F}}$ 
and \textit{approximation order} $\preceq_{\mathcal{F}}$. Both orders are defined as follows for defined leafs.
\[
    f_1 \sqsubseteq_{\mathcal{F}} f_2  \iff  f_1 \preceq_{\mathcal{F}} f_2 \iff
    \forall x \in \mathbb{Z}^{|\mathcal{X}|} \colon f_1(x) \leq f_2(x)
\]
Undefined leafs are ordered according to the Hasse diagrams in figure~\ref{fig:function_comp_approx_hasse}. \\\\

\begin{figure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \begin{tikzpicture}[]
            \node (top) at (0,2) {$\top_{\mathcal{F}}$};
            \node (f) at (0,1) {$f \colon  \mathbb{Z}^{|\mathcal{X}|} \rightarrow \mathbb{N} $};
            \node (bot) at (0,0) {$\bot_{\mathcal{F}}$};
            \draw (top) -- (f) -- (bot);
        \end{tikzpicture}
        \caption{\textit{computational order} $\sqsubseteq_{\mathcal{F}}$}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \begin{tikzpicture}[]
            \node (top) at (0,2) {$\top_{\mathcal{F}}$};
            \node (bot) at (2,2) {$\bot_{\mathcal{F}}$};
            \node (f) at (1,0) {$f \colon  \mathbb{Z}^{|\mathcal{X}|} \rightarrow \mathbb{N} $};
            \draw (top) -- (f) -- (bot);
        \end{tikzpicture}
        \caption{\textit{approximation order} $\preceq_{\mathcal{F}}$}
    \end{subfigure}
    \caption{Hasse diagrams for $\sqsubseteq_{\mathcal{F}}$ and $\preceq_{\mathcal{F}}$
    } 
    \label{fig:function_comp_approx_hasse}
\end{figure}

Now we lift these orders to decision trees. The \textit{computational order} $\sqsubseteq_{\mathcal{T}}$ 
and \textit{approximation order} $\preceq_{\mathcal{T}}$ are defined by leaf-wise comparison of two decision trees with the corresponding orders 
$\sqsubseteq_{\mathcal{F}}$ and $\preceq_{\mathcal{F}}$. A more detailed description can be found in~\cite{UrbanPhd}. 
Intuitively, the \textit{computational order} $\sqsubseteq_{\mathcal{T}}$ is an approximation of the \textit{computational order} $\sqsubseteq$ defined 
in section~\ref{sec:ctl_semantics} (definition~\ref{def:computational_order}).\\

The \textit{approximation order} $\preceq_{\mathcal{T}}$ is used to define sound abstractions.

\begin{definition}\label{def:sound_abstraction}
    Let $\alpha \in \Sigma \rightarrow \mathbb{N}$ denote the abstraction function from ranking functions to decision trees.
    A decision tree $t \in \mathcal{T}$ is a sound abstraction of a ranking function $f \in \Sigma \rightarrow \mathbb{N}$ if
    $\alpha(f) \preceq_{\mathcal{T}} t$.
\end{definition}

This definition allows us to use $\top_\mathcal{F}$ leafs in decision trees to represent uncertainty about some values of a ranking function.
Due to definition~\ref{def:sound_abstraction} we can use such a decision tree to soundly abstract a more precise ranking function.


\subsection{Join}\label{sec:tree_join}
Two trees can be joined to form the union of all partitions represented by the two trees. There are two variations of the join operator. 
The \textit{computational join} $\sqcup_{\mathcal{T}} \colon (\mathcal{T}_{NIL} \times \mathcal{T}_{NIL}) \rightarrow \mathcal{T}_{NIL}$
and the \textit{approximation join} $\curlyvee_{\mathcal{T}} \colon (\mathcal{T}_{NIL} \times \mathcal{T}_{NIL}) \rightarrow \mathcal{T}_{NIL}$. 
The first one joins leaf nodes with $\sqsubseteq_{\mathcal{F}}$ the latter with $\preceq_{\mathcal{F}}$. Figure~\ref{fig:decision_tree_join_example} 
demonstrates the difference between the two join types. When joining two trees where one leaf is defined and one is undefined 
(see left leaf in $t_1$ and $t_2$), the \textit{computational join} will preserve the defined leaf
and the \textit{approximation join} will make the leaf undefined. For detailed description of the two join types see~\cite{UrbanPhd}.

\begin{figure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \begin{tikzpicture}[node distance=1.5cm]
            \tikzset{
                inner_node/.style={draw, shape = rectangle, thick},
                leaf/.style={draw, shape = rectangle, rounded corners, thick}
            }
            \node[inner_node] (A) {$x \leq 0$};
            \node[leaf] (B) [below left of= A] {$\lambda x.\ 2x$};
            \node[leaf] (C) [below right of= A] {$\lambda x. \ 3x$};

            \path (A) edge              node {} (B);
            \path (A) edge [dashed]              node {} (C);
        \end{tikzpicture}
        \caption{$t_1$}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \begin{tikzpicture}[node distance=1.5cm]
            \tikzset{
                inner_node/.style={draw, shape = rectangle, thick},
                leaf/.style={draw, shape = rectangle, rounded corners, thick}
            }
            \node[inner_node] (A) {$x \leq 0$};
            \node[leaf] (B) [below left of= A] {$\bot_{\mathcal{F}}$};
            \node[leaf] (C) [below right of= A] {$\lambda x. \ 5x$};
            \path (A) edge              node {} (B);
            \path (A) edge [dashed]              node {} (C);
        \end{tikzpicture}
        \caption{$t_2$}
    \end{subfigure}
    \par\bigskip
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \begin{tikzpicture}[node distance=1.5cm]
            \tikzset{
                inner_node/.style={draw, shape = rectangle, thick},
                leaf/.style={draw, shape = rectangle, rounded corners, thick}
            }
            \node[inner_node] (A) {$x \leq 0$};
            \node[leaf] (B) [below left of= A] {$\lambda x.\ 2x$};
            \node[leaf] (C) [below right of= A] {$\lambda x. \ 5x$};
            \path (A) edge              node {} (B);
            \path (A) edge [dashed]              node {} (C);
        \end{tikzpicture}
        \caption{$t_1 \sqcup_{\mathcal{T}} t_2$}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \begin{tikzpicture}[node distance=1.5cm]
            \tikzset{
                inner_node/.style={draw, shape = rectangle, thick},
                leaf/.style={draw, shape = rectangle, rounded corners, thick}
            }
            \node[inner_node] (A) {$x \leq 0$};
            \node[leaf] (B) [below left of= A] {$\bot_{\mathcal{F}}$};
            \node[leaf] (C) [below right of= A] {$\lambda x. \ 5x$};

            \path (A) edge              node {} (B);
            \path (A) edge [dashed]              node {} (C);
        \end{tikzpicture}
        \caption{$t_1 \curlyvee_{\mathcal{T}} t_2$}
    \end{subfigure}

    \caption{Decision Tree Join Example}
    \label{fig:decision_tree_join_example}
\end{figure}

\subsection{Meet}\label{sec:tree_meet}

\subsection{Filter}
TODO

\subsection{Reset}
TODO

\subsection{Backward Assign}
TODO



\begin{algorithm}                      
    \caption{Tree Join Helper (TODO not sure if ill new you here)}         
    \label{alg:tree_join_helper}       
    \begin{algorithmic}
        \LineComment{$t_{left}, t_{right} \in \mathcal{T}_{NIL}$}
        \LineComment{$f_{LEAF} \in \mathcal{P}(\mathcal{C}) \rightarrow \mathcal{F} \rightarrow \mathcal{F} \rightarrow \mathcal{T} $}
        \LineComment{$f_{LeftNIL}, f_{RightNIL} \in \mathcal{P}(\mathcal{C}) \rightarrow \mathcal{F} \rightarrow \mathcal{T} $}
        \Function{tree\_join\_helper}{$t_{left}, t_{right}, f_{LEAF}, f_{LeftNIL}, f_{RightNIL}$} 

        \Function{aux}{$t_l, t_r, C$} 

        \If{$isNil(t_l) \land isNil(t_r)$}
            \State \Return $NIL$
        \ElsIf{$isNil(t_l) \land isLeaf(t_r)$}
            \State \Return $f_{LeftNIL}(C, t_r.f)$
        \ElsIf{$isLeaf(t_l) \land isNil(t_r)$}
            \State \Return $f_{RightNIL}(C, t_l.f)$
        \ElsIf{$isLeaf(t_l) \land isLeaf(t_r)$}
            \State \Return $f_{LEAF}(C, t_l.f t_r.f)$
        \Else
            \Comment{assert $t_l.c = t_r.c$}
            \State $l \gets \Call{aux}{t_l.l, t_r.l,  \{t_l.c\} \cup C}$
            \State $r \gets \Call{aux}{t_l.r, t_r.r, \{\neg t_l.c\} \cup C}$
            \State \Return $NODE\{t_l.c\} \colon l ; r $
        \EndIf

        \EndFunction

        \State $(t_l, t_r) \gets \Call{tree\_unification}{t_{left}, t_{right}}$
        \State \Return \Call{aux}{$t_l, t_r$}
        \EndFunction
\end{algorithmic}
\end{algorithm}




\section{Abstract Semantics for CTL}\label{sec:abstract_ctl_semantics}

In this section we present a sound, computable approximation of the CTL semantics $\tau_\Phi$.
Computing the ranking function $\tau_\Phi$ is in general not computable as one can easily encode the 
halting problem in $\tau_\Phi$. Therefore, we approximation $\tau_\Phi$ by using
the decision tree abstract domain (section~\ref{sec:decision_tree_abstract_domain}) to approximate ranking functions 
in terms of piecewise defined ranking functions.

\begin{definition}
    The abstract CTL semantics $\tau^{\sharp}_\Phi \in \mathcal{L} \rightarrow \mathcal{T}$ is a sound approximation of the
    CTL semantics $\tau_\Phi$ with regards to the \textit{approximation order} $\preceq$.
\end{definition}

Recall that the CTL semantics $\tau_\Phi \in \Sigma \rightarrow \mathbb{N}$ is a partial function that 
assigns numerical values to program states $\sigma \in \Sigma$. 
In the abstract version, program states are partitioned by decision trees $t \in \mathcal{T}$ and 
grouped by program labels $l \in \mathcal{L}$. A program satisfies a given CTL property $\Phi$ if the decision tree of the
initial program label $\tau^{\sharp}_\Phi(t_{init})$ is defined over all partitions 
(TODO introduce notion of defined w.r.t decision trees).
\\

The following sections present how to compute $\tau^{\sharp}_\Phi$ for each CTL operator. 
We start with the basic operators $\land, \lor, \neg$ and atomic propositions. 
These can be computed directly for each program label. 
Then we present how to compute the universal $\forall U$, $\forall\bigcirc$ and $\forall\square$ operators through fixed-point iteration. 
Followed by a discussion on how to adapt the universal operators to their existential version. 
Note that the abstract CTL semantics are computed recursively. The recursion stops at atomic propositions.

\subsection{Path Independent Operators}

Atomic propositions are path independent, therefore $\tau^{\sharp}_a$ assigns the same decision tree to 
each program label $l \in \mathcal{L}$. This decision tree assigns the constant value $0$ to all partitions that satisfy the atomic proposition $a$.
We compute this tree by using the $\text{RESET} \llbracket a \rrbracket$ operator on the totally undefined decision tree $\bot$ (see section XY TODO). 

\begin{definition}\label{def:abstract_ctl_semantics_atomic}
    Abstract CTL semantics for atomic propositions
    \begin{align}
        \tau^{\sharp}_{a} \eqdef \ \lambda l. \ \text{RESET} \llbracket a \rrbracket \bot
    \end{align}
\end{definition}


\begin{tcolorbox}
    \subsubsection*{Fixing the \text{RESET} operator}
    The $\text{RESET}\llbracket a \rrbracket$ operator was originally introduced in~\cite{UrbanPhd} in the context of abstract guarantee semantics
    and would overapproximate the set of partitions that satisfy the atomic proposition $a$. 
    During the work on this thesis, we discovered that this original definition is actually unsound and leads to incorrect analysis results. \\
    
    The problem is best described using an example. Consider the abstract CTL semantics $\tau^{\sharp}_{x^2 < y^3 + 1}$. 
    The non linear constraint $x^2 < y^3 + 1$ can usually not be represented by any of the common numerical domains. 
    An overapproximating implementation of $\text{RESET}\llbracket x^2 < y^3 + 1 \rrbracket$ will therefore
    reset some pairs $(x, y)$ for which $x^2 < y^3 + 1$ does not hold which is unsound as to the definition of
    the CTL semantics $\tau_{x^2 < y^3 + 1}$. Note that this problem propagates to more complex temporal properties that
    depend on atomic propositions.\\

    We resolve this problem by using an underapproximating implementation of $\text{RESET}$ as presented
    in section XY (TODO ref).
\end{tcolorbox}

Now we define the abstract CTL semantics for the logical operators $\land$, $\lor$ and $\neg$.

\begin{definition}\label{def:abstract_ctl_semantics_logic_operators}
    Abstract CTL semantics for logic operators
    \begin{align}
        \tau^{\sharp}_{\Phi_1 \land \Phi_2} &\eqdef \ \lambda l. \ (\tau^{\sharp}_{\neg \Phi_1}l) \ \sqcup_{\mathcal{T}} \ (\tau^{\sharp}_{\neg \Phi_2}l)
        \label{eq:abstract_ctl_and}\\
        \tau^{\sharp}_{\Phi_1 \lor \Phi_2} &\eqdef \ \lambda l. \ (\tau^{\sharp}_{\neg \Phi_1}l) \ \sqcap_{\mathcal{T}} \ (\tau^{\sharp}_{\neg \Phi_2}l)
        \label{eq:abstract_ctl_or}\\
        \tau^{\sharp}_{\neg \Phi} &\eqdef \ \lambda l. \ \text{COMPLEMENT} \ (\tau^{\sharp}_{\neg \Phi}l)
        \label{eq:abstract_ctl_not}
    \end{align}
\end{definition}

The abstract CTL semantics for $\land$ and $\lor$ (equations~\ref{eq:abstract_ctl_and} and~\ref{eq:abstract_ctl_or}) combine the decision trees
of the nested properties piecewise for each program label.\\

The \textit{computational join} $\sqcup_{\mathcal{T}}$ is used to combine the two trees (see section~\ref{sec:tree_join}) in
case of the logical $\lor$. This operator forms the union of the two decision trees. 
Note that we use the computational version of the join operator to include partitions that are defined in at least one of the two trees. 
If a partition is defined in both trees, the smallest upper bound of the assigned value is formed to approximate the concrete CTL semantics.\\

The corresponding definition for the logical $\land$ operator forms the intersection of the two trees by using the
\textit{computational meet} $\sqcap_{\mathcal{T}}$ (see section~\ref{sec:tree_meet}). 
As with the logical $\lor$, the smallest upper bound is formed if a partition is defined in both trees. 
By using the computational version of the operator, 
we ensure that no $NIL$ leafs are introduced when forming the intersection.\\

For the logical $\neg$ operator we introduce the $\text{COMPLEMENT}$ operator. 
This operator replaces all defined leafs with a $\bot$-leaf and all $\bot$-leafs with the constant value $0$.
By doing so, all states that originally satisfied the property do not satisfy it any more and vice-versa.
However one has to be careful when changing a partition from undefined to defined. Decision trees are an 
approximation of the concrete CTL semantics. Therefore not all states that are undefined in the abstract decision tree
are actually undefined in the concrete ranking function. Partitions that are undefined because of this uncertainty are marked with a 
$\top$-leaf. To ensure soundness, these leafs have to be ignored when forming the complement of a decision tree.   
The $\text{COMPLEMENT}$ operator is implemented in algorithm~\ref{alg:tree_complement}.

\begin{algorithm}                      
    \caption{Tree Complement}         
    \label{alg:tree_complement}       
    \begin{algorithmic}
        \Function{complement}{$t$} 
        \Comment{$t \in \mathcal{T}_{NIL}$}
        \If{$(isNode(t) \land t.f = \top) \lor isNil(t)$}
            \State \Return $t$
            \Comment{ignore $\top$ and $NIL$}
        \ElsIf{$isLeaf(t) \land t.f = \bot$}
            \State \Return $LEAF: 0$
            \Comment{undefined becomes defined}
        \ElsIf{$isLeaf(t)$}
            \State \Return $LEAF: \bot$
            \Comment{defined becomes undefined}
        \Else
            \State $l \gets \Call{complement}{t.l}$
            \State $r \gets \Call{complement}{t.r}$
            \State \Return $NODE\{t.c \}: l ; r$
        \EndIf
        \EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Path Dependent Operators}

In this section we describe how the abstract CTL semantics for the path dependent operators 
($\forall\bigcirc\Phi,\ \exists\bigcirc\Phi,\ \forall(\Phi_1 U \Phi_2),\ \exists(\Phi_1 U \Phi_2),\ \forall\square\Phi,\ \exists\square\Phi$)
are defined.\\

First, we define the two functions ${\llbracket stmt \rrbracket}_o \in \mathcal{T}_{NIL} \rightarrow \mathcal{T}_{NIL}$
and ${\llbracket stmt \rrbracket}_u \in \mathcal{T}_{NIL} \rightarrow \mathcal{T}_{NIL}$. 
The first one uses overapproximation on the underlying numerical domains, the second one underapproximation.\\

Both functions implement the effect of backward propagating an edge 
in the control-flow-graph i.e. the effect of executing a statement. 
Assume that we computed a decision tree for the target node of some edge. 
This decision tree represents the value of the ranking function for this node. 
By applying ${\llbracket \cdot \rrbracket}$ to this tree, we compute the decision tree 
that holds before executing the statement i.e.\ the value of the ranking function at the source node of this edge.



\begin{definition}\label{def:basic_expression_transformer}
    Abstract semantics for basic statements
    \begin{align*}
        {\llbracket \mathtt{skip} \rrbracket}_o \eqdef \lambda t. \ \text{STEP}(t)\\
        {\llbracket bexp \rrbracket}_o \eqdef \lambda t. \ \text{B-ASSIGN}(t)\\
        {\llbracket X := aexp \rrbracket}_o \eqdef \lambda t. \ \text{FILTER}(t)\\
        \\
        {\llbracket \mathtt{skip} \rrbracket}_u \eqdef \lambda t. \ \text{STEP}(t)\\
        {\llbracket bexp \rrbracket}_u \eqdef \lambda t. \ \text{B-ASSIGN-UNDER}(t)\\
        {\llbracket X := aexp \rrbracket}_u \eqdef \lambda t. \ \text{FILTER-UNDER}(t)\\
    \end{align*}
\end{definition}

The \texttt{skip} statement is handled by the STEP operator. This operator increases the value of all defined
partitions in the decision tree by one (see XY TODO). Recall that a defined partition in a decision tree represents a set of states that satisfies 
some CTL property. The associated value is an upper bound on the number of steps until some condition is reached. 
By executing \texttt{skip} this number is incremented by one.
For assignments and boolean conditions we use the corresponding B-ASSIGN and FILTER 
operators that were introduced in section~\ref{sec:decision_tree_abstract_domain}.\\

The definitons for the remaining path dependent operators all depend on $\llbracket \cdot \rrbracket$.

\subsubsection*{Until}
The abstract CTL semantics for universal and existential `until' properties are defined as the least fixed-point of the abstract transformers
\[
\phi^\sharp_{\forall(\Phi_1 U \Phi_2)}, \phi^\sharp_{\exists(\Phi_1 U \Phi_2)} 
\in (\mathcal{L} \rightarrow \mathcal{T}_{NIL}) \rightarrow (\mathcal{L} \rightarrow \mathcal{T}_{NIL})
\]
starting from the 
totally undefind decision tree $\bot$ (see definition~\ref{def:abstract_until_semantics}).
We will first discuss the universal version and then explain what changes for the existential case.\\

\begin{definition}\label{def:abstract_until_semantics}
    Abstract semantics for `until' operator.
    \setlength{\jot}{15pt}
    \begin{align*}
        \tau^\sharp_{\forall(\Phi_1 U \Phi_2)} \ &\eqdef \ \text{lfp}^{\sqsubseteq_{\mathcal{T}}}_{\bot} \phi^\sharp_{\forall(\Phi_1 U \Phi_2)}\\
        t_{\curlyvee}(l)  \ &\eqdef \ \bigcurlyvee\limits_{(l, stmt, l') \ \in \ out(l) } {\llbracket stmt \rrbracket}_{o} ( m(l')) \\
        \phi^\sharp_{\forall(\Phi_1 U \Phi_2)}(m)l \ &\eqdef \ \text{UNTIL}\llbracket \tau^\sharp_{\Phi_1}(l), \tau^\sharp_{\Phi_2}(l) \rrbracket (t_{\curlyvee}(l))  \\\\
        %
        %
        \tau^\sharp_{\exists(\Phi_1 U \Phi_2)} \ &\eqdef \ \text{lfp}^{\sqsubseteq_{\mathcal{T}}}_{\bot} \phi^\sharp_{\exists(\Phi_1 U \Phi_2)}\\
        t_{\sqcup}(l) \ &\eqdef \ \bigsqcup\limits_{(l, stmt, l') \ \in \ out(l) } {\llbracket stmt \rrbracket}_{u} (m(l')) \\
        \phi^\sharp_{\exists(\Phi_1 U \Phi_2)}(m)l \ &\eqdef \ \mathtt{UNTIL}\llbracket \tau^\sharp_{\Phi_1}(l), \tau^\sharp_{\Phi_2}(l) \rrbracket ( t_{\sqcup}(l))
    \end{align*}
\end{definition}


Recall that $out(l)$ denotes all outgoing edges of node $l$ leading to its immediate successors nodes. Every edge is labeled with a statement. 
The abstract transformer $\phi^\sharp_{\forall(\Phi_1 U \Phi_2)}$ computes decision trees for each node $l$ in the 
control-flow-graph, based on the decision trees of its successor nodes.\\

First, the decision tree of each successor node $l'$ is applied to the ${\llbracket stmt \rrbracket}_{o}$ function. 
This approximates the effect of transitioning from $l$ to $l'$. The resulting decision tree approximates the value of 
the ranking function before executing the statement.\\

If a node has multiple successor nodes then the resulting decision trees 
are combined using the \textit{approximation join} $\curlyvee$. The \textit{approximation join} discards all partitions (i.e.\ makes them undefined)
of decision trees that are not defined for all successor nodes. By doing so, we approximate the semantic of the universal path  
quantifier $\forall$.\\ 

We use the overapproximating version of the ${\llbracket \cdot \rrbracket}_{o}$ function. 
This might temporarely lead to unsound decision trees due to overapproximation. 
Decision trees produced by ${\llbracket \cdot \rrbracket}_{o}$ can contain defined partitions for states that are unfeasible 
among that path in the control-flow-graph. For the universal case however, this is not a problem since the 
\textit{approximation join} only keeps those partitions which are feasible among all paths. 
Partitions that are unfeasible among some paths are discarded.\\

Finally the result of joining the decision trees of the immediate predecessors are 
applied to he $UNTIL\llbracket \tau^\sharp_{\Phi_1}, \tau^\sharp_{\Phi_2} \rrbracket $ operator. 
The purpose of his operator is to implement the semantics of the `until' operator. 
All partitions that satisfy $\Phi_1$ are set to zero and all partitions that neither 
satisfy $\Phi_1$ nor $\Phi_2$ are discarded (see algorithm~\ref{alg:tree_until}).
That way we end up with a decision tree that is only defined for those partitions which satisfy $\forall(\Phi_1 U \Phi_2)$.\\


The abstract tansformer for the existential case follows the same structure as in the universal case. 
Instead of using the \textit{approximation join} it uses the \textit{computational join} $\sqcup$ 
to approximate the semantics of the $\exists$ path quantifier. 
The \textit{computational join} preserves all partitions that are defined for at least one decision tree. 
Note however, that all decision trees passed to the \textit{computation join} must be sound since we can no longer 
rely on the join operator to discard unfeasible partitions. Therefore we apply the underapproximating ${\llbracket stmt \rrbracket}_{u}$ 
function when processing satements to guarantee soundness.


\subsubsection*{Global}
The abstract CTL semantics for universal and existential `global' properties are defined as the greatest fixed-point of the abstract transformers
\[
    \phi^\sharp_{\forall\square\Phi}, \phi^\sharp_{\exists\square\Phi} 
\in (\mathcal{L} \rightarrow \mathcal{T}_{NIL}) \rightarrow (\mathcal{L} \rightarrow \mathcal{T}_{NIL})
\]
starting from the abstract CTL semantics $\tau^\sharp_\Phi$ of the inner CTL property (see definition~\ref{def:abstract_global_semantics}).

\begin{definition}\label{def:abstract_global_semantics}
    Abstract semantics for `global' operator.
    \setlength{\jot}{15pt}
    \begin{align*}
        \tau^\sharp_{\forall\square\Phi} \ &\eqdef \ \text{gfp}^{\sqsubseteq_{\mathcal{T}}}_{\tau^\sharp_\Phi} \phi^\sharp_{\forall\square\Phi}\\
        t_{\curlyvee}(l)  \ &\eqdef \ \bigcurlyvee\limits_{(l, stmt, l') \ \in \ out(l) } {\llbracket stmt \rrbracket}_{o} ( m(l')) \\
        \phi^\sharp_{\forall\square\Phi}(m)l \ &\eqdef \ \mathtt{MASK}\llbracket t_{\curlyvee}(l)\rrbracket (m(l))  \\\\
        %
        \tau^\sharp_{\exists\square\Phi} \ &\eqdef \ \text{gfp}^{\sqsubseteq_{\mathcal{T}}}_{\tau^\sharp_\Phi} \phi^\sharp_{\exists\square\Phi}\\
        t_{\sqcup}(l)  \ &\eqdef \ \bigsqcup\limits_{(l, stmt, l') \ \in \ out(l) } {\llbracket stmt \rrbracket}_{u} ( m(l')) \\
        \phi^\sharp_{\exists\square\Phi}(m)l \ &\eqdef \ \mathtt{MASK}\llbracket t_{\sqcup}(l) \rrbracket (m(l))  \\\\
    \end{align*}
\end{definition}

The abstract transformer for the `global' operator uses the same approach as the `until' operator to join outgoing edges w.r.t $\forall$ and $\exists$.
In the final step however, the current decision tree $m(l)$ is masked with the updated decision tree $t_{\curlyvee}(l)$ and $t_{\sqcup}(l)$.
Masking means the all defined partitions in $m(l)$ that are not also defined in $t_{\curlyvee}(l)$ (or $t_{\sqcup}(l)$) are discarded. 
Note that the decision tree $\tau^\sharp_\Phi(l_{exit})$ is the totally undefind decision tree $\bot$.
That way all states that do not satisfy $\Phi$ indefinitely among all (or some) paths are iteratively 
removed from the decision tree until a fixed-point is reached. 
The \texttt{MASK} operator is defined in algorithm~\ref{alg:tree_mask}.




\subsubsection*{Next}
The abstract CTL semantics for the `next' operator are given in definition~\ref{def:abstract_next_semantics}. 

\begin{definition}\label{def:abstract_next_semantics}
    Abstract semantics for `next' operator.
    \setlength{\jot}{15pt}
    \begin{align*}
        t_{\curlyvee}(l) \ &\eqdef \  
        \bigcurlyvee\limits_{(l, stmt, l') \ \in \ out(l) } {\llbracket stmt \rrbracket}_{o}(\tau^\sharp_\Phi(l)) \\
        \tau^\sharp_{\forall\bigcirc\Phi} \ &\eqdef \ \lambda l. \ \mathtt{ZERO}(t_{\curlyvee}(l))\\\\
        %
        t_{\sqcup}(l) \ &\eqdef \  
        \bigsqcup\limits_{(l, stmt, l') \ \in \ out(l) } {\llbracket stmt \rrbracket}_{u}(\tau^\sharp_\Phi(l)) \\
        \tau^\sharp_{\exists\bigcirc\Phi} \ &\eqdef \ \lambda l. \ \mathtt{ZERO}(t_{\sqcup}(l))\\
    \end{align*}
\end{definition}

As opposed to the `until' and `global' operator, the decision trees for each label only depends on the immediate successor nodes.
Therefore no fixed-point iteration is necessary. Each node is computed in one step based on the immediate successor nodes.
Outgoing edges are joined as describe for the `until' and `global' operators. The resulting value is then applied to the \texttt{ZERO}
operator which sets all defined partitions to zero (see algorithm~\ref{alg:tree_zero}).




\begin{algorithm}                      
    \caption{Tree Until Filter}         
    \label{alg:tree_until_filter}       
    \begin{algorithmic}
        \Function{filter\_until}{$t, t_{\text{valid}}$} 
            \If{$isNil(t) \lor isNil(t_{\text{valid}})$}
                \LineComment{ignore $NIL$ nodes}
                \State \Return $t$
            \ElsIf{$isLeaf(t) \land isLeaf(t_{\text{valid}}) \land isDefined(t)$}
                \LineComment{$t$ is defined in $t_{\text{valid}}$}
                \State \Return $t$
            \ElsIf{$isLeaf(t) \land isLeaf(t_{\text{valid}}) \land  \neg isDefined(t)$}
                \LineComment{$t$ is not defined in $t_{\text{valid}}$, make undefined}
                \State \Return $LEAF: \bot$
            \Else
                \State $l \gets \Call{filter\_until}{t.l, t_{\text{valid}}.l}$
                \State $r \gets \Call{filter\_until}{t.r, t_{\text{valid}}.r}$
                \State \Return $NODE\{t.c \}: l ; r$
            \EndIf 
        \EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}                      
    \caption{Tree Until}         
    \label{alg:tree_until}       
    \begin{algorithmic}
        \Function{reset\_until}{$t, t_{\text{reset}}$} 
            \If{$isNil(t) \lor isNil(t_{\text{reset}})$}
                \LineComment{ignore $NIL$ nodes}
                \State \Return $t$
            \ElsIf{$isLeaf(t) \land isLeaf(t_{\text{reset}}) \land isDefined(t)$}
                \LineComment{$t$ is defined in $t_{\text{valid}}$, reset leaf}
                \State \Return $LEAF: 0$
            \ElsIf{$isLeaf(t) \land isLeaf(t_{\text{valid}}) \land  \neg isDefined(t)$}
                \LineComment{$t$ is undefined in $t_{\text{valid}}$, keep as is}
                \State \Return $t$
            \Else
                \State $l \gets \Call{reset\_until}{t.l, t_{\text{reset}}.l}$
                \State $r \gets \Call{reset\_until}{t.r, t_{\text{reset}}.r}$
                \State \Return $NODE\{t.c \}: l ; r$
            \EndIf 
        \EndFunction
        \Function{until$\llbracket t_{\Phi_1}, t_{\Phi_2} \rrbracket$}{$t$} 
            \Comment{$t, t_{\Phi_1}, t_{\Phi_2} \in \mathcal{T}_{NIL}$}
            \State $(t_1, t_2) \gets \Call{tree\_unification}{t, t_{\Phi_1} \sqcup t_{\Phi_2}}$
            \State $t_{\text{filtered}} \gets \Call{filter\_until}{t_1, t_2}$
            \State $(t_1, t_2) \gets \Call{tree\_unification}{t_{\text{filtered}}, t_{\Phi_2}}$
            \State \Return $\Call{reset\_until}{t_1, t_2}$
        \EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}                      
    \caption{Tree Mask}         
    \label{alg:tree_mask}       
    \begin{algorithmic}
        \Function{mask$\llbracket t_{\text{mask}} \rrbracket$}{$t$} 

            \Function{mask\_aux}{$t, t_{\text{mask}} $} 
                \If{$isNil(t) \lor isNil(t_{\text{reset}})$}
                    \LineComment{ignore $NIL$ nodes}
                    \State \Return $t$
                \ElsIf{$isLeaf(t) \land isDefined(t) \land isLeaf(t_{\text{mask}})$}
                    \If{$isDefined(t) \land \neg isDefined(t_{\text{mask}})$}
                        \LineComment{$t$ is defined and $t_{\text{mask}}$ is undefined, discard leaf}
                        \State \Return $LEAF: \bot$
                    \Else
                        \State \Return $t$
                    \EndIf
                \Else
                    \State $l \gets \Call{mask}{t.l, t_{\text{mask}}.l}$
                    \State $r \gets \Call{mask}{t.r, t_{\text{mask}}.r}$
                    \State \Return $NODE\{t.c \}: l ; r$
                \EndIf 
            \EndFunction

            \State $(t_1, t_2) \gets \Call{tree\_unification}{t, t_{\text{MASK}}}$
            \State \Return $\Call{mask\_aux}{t_1, t_2}$
        \EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}                      
    \caption{Tree Zero}         
    \label{alg:tree_zero}       
    \begin{algorithmic}
        \Function{zero}{$t$} 
            \If{$isLeaf(t) \land isDefined(t)$}
                \State \Return $LEAF: 0$
            \ElsIf{$isNode(t)$}
                \State $l \gets \Call{zero}{t.l}$
                \State $r \gets \Call{zero}{t.r}$
                \State \Return $NODE\{t.c \}: l ; r$
            \Else
                \State \Return $t$
            \EndIf 
        \EndFunction
\end{algorithmic}
\end{algorithm}



\pagebreak

\bibliographystyle{IEEEbib}
\bibliography{bibl_conf}



\end{document}
